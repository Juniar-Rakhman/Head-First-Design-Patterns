# Design Patterns

Design Patterns give you a **shared vocabulary** with other developers:

- shared pattern vocabularies are powerful
- pattern allow you to say more with less
- talking at the pattern level allows you to stay "in the design" longer
- shared vocabularies can turbo charge your development team
- shared vocabularies encourage more junior developers to get up to speed

1. the **Strategy Pattern** defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it;
2. the **Observer Pattern** defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically;
3. the **Decorator Pattern** attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to sub-classing for extending functionality;
4. the **Factory Method Pattern** defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses;
5. the **Abstract Factory Pattern** provides an interface for creating families of related or dependent objects without specifying their concrete classes;
6. the **Singleton Pattern** ensures a class has only one instance, and provides a global point of access to it;
7. the **Command Pattern** encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undo-able operations;
8. the **Adapter Pattern** converts the interface of a class into another interface the clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.
9. the **Facade Pattern** provides a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.
